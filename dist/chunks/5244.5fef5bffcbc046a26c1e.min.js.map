{"version":3,"file":"chunks/5244.5fef5bffcbc046a26c1e.min.js","mappings":"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","sources":["webpack://@patternslib/patterns-dist/./node_modules/@patternslib/patternslib/src/core/jquery-ext.js","webpack://@patternslib/patterns-dist/./node_modules/@patternslib/patternslib/src/pat/ajax/ajax.js","webpack://@patternslib/patterns-dist/./node_modules/@patternslib/patternslib/src/pat/inject/inject.js","webpack://@patternslib/patterns-dist/./node_modules/@patternslib/patternslib/src/pat/markdown/markdown.js"],"sourcesContent":["/**\n * @license\n * Patterns @VERSION@ jquery-ext - various jQuery extensions\n *\n * Copyright 2011 Humberto Sermeño\n */\n\nimport $ from \"jquery\";\n\nvar methods = {\n    init: function (options) {\n        var settings = {\n            time: 3 /* time it will wait before moving to \"timeout\" after a move event */,\n            initialTime: 8 /* time it will wait before first adding the \"timeout\" class */,\n            exceptionAreas: [] /* IDs of elements that, if the mouse is over them, will reset the timer */,\n        };\n        return this.each(function () {\n            var $this = $(this),\n                data = $this.data(\"timeout\");\n\n            if (!data) {\n                if (options) {\n                    $.extend(settings, options);\n                }\n                $this.data(\"timeout\", {\n                    lastEvent: new Date(),\n                    trueTime: settings.time,\n                    time: settings.initialTime,\n                    untouched: true,\n                    inExceptionArea: false,\n                });\n\n                $this.on(\"mouseover.timeout\", methods.mouseMoved);\n                $this.on(\"mouseenter.timeout\", methods.mouseMoved);\n\n                $(settings.exceptionAreas).each(function () {\n                    $this\n                        .find(this)\n                        .live(\n                            \"mouseover.timeout\",\n                            { parent: $this },\n                            methods.enteredException\n                        )\n                        .live(\n                            \"mouseleave.timeout\",\n                            { parent: $this },\n                            methods.leftException\n                        );\n                });\n\n                if (settings.initialTime > 0) $this.timeout(\"startTimer\");\n                else $this.addClass(\"timeout\");\n            }\n        });\n    },\n\n    enteredException: function (event) {\n        var data = event.data.parent.data(\"timeout\");\n        data.inExceptionArea = true;\n        event.data.parent.data(\"timeout\", data);\n        event.data.parent.trigger(\"mouseover\");\n    },\n\n    leftException: function (event) {\n        var data = event.data.parent.data(\"timeout\");\n        data.inExceptionArea = false;\n        event.data.parent.data(\"timeout\", data);\n    },\n\n    destroy: function () {\n        return this.each(function () {\n            var $this = $(this),\n                data = $this.data(\"timeout\");\n\n            $(window).off(\".timeout\");\n            data.timeout.remove();\n            $this.removeData(\"timeout\");\n        });\n    },\n\n    mouseMoved: function () {\n        var $this = $(this),\n            data = $this.data(\"timeout\");\n\n        if ($this.hasClass(\"timeout\")) {\n            $this.removeClass(\"timeout\");\n            $this.timeout(\"startTimer\");\n        } else if (data.untouched) {\n            data.untouched = false;\n            data.time = data.trueTime;\n        }\n\n        data.lastEvent = new Date();\n        $this.data(\"timeout\", data);\n    },\n\n    startTimer: function () {\n        var $this = $(this),\n            data = $this.data(\"timeout\");\n        var fn = function () {\n            var data = $this.data(\"timeout\");\n            if (data && data.lastEvent) {\n                if (data.inExceptionArea) {\n                    setTimeout(fn, Math.floor(data.time * 1000));\n                } else {\n                    var now = new Date();\n                    var diff = Math.floor(data.time * 1000) - (now - data.lastEvent);\n                    if (diff > 0) {\n                        // the timeout has not ocurred, so set the timeout again\n                        setTimeout(fn, diff + 100);\n                    } else {\n                        // timeout ocurred, so set the class\n                        $this.addClass(\"timeout\");\n                    }\n                }\n            }\n        };\n\n        setTimeout(fn, Math.floor(data.time * 1000));\n    },\n};\n\n$.fn.timeout = function (method) {\n    if (methods[method]) {\n        return methods[method].apply(this, Array.prototype.slice.call(arguments, 1));\n    } else if (typeof method === \"object\" || !method) {\n        return methods.init.apply(this, arguments);\n    } else {\n        $.error(\"Method \" + method + \" does not exist on jQuery.timeout\");\n    }\n};\n\n// Custom jQuery selector to find elements with scrollbars\n$.extend($.expr[\":\"], {\n    scrollable: function (element) {\n        var vertically_scrollable, horizontally_scrollable;\n        if (\n            $(element).css(\"overflow\") === \"scroll\" ||\n            $(element).css(\"overflowX\") === \"scroll\" ||\n            $(element).css(\"overflowY\") === \"scroll\"\n        )\n            return true;\n\n        vertically_scrollable =\n            element.clientHeight < element.scrollHeight &&\n            ($.inArray($(element).css(\"overflowY\"), [\"scroll\", \"auto\"]) !== -1 ||\n                $.inArray($(element).css(\"overflow\"), [\"scroll\", \"auto\"]) !== -1);\n\n        if (vertically_scrollable) return true;\n\n        horizontally_scrollable =\n            element.clientWidth < element.scrollWidth &&\n            ($.inArray($(element).css(\"overflowX\"), [\"scroll\", \"auto\"]) !== -1 ||\n                $.inArray($(element).css(\"overflow\"), [\"scroll\", \"auto\"]) !== -1);\n        return horizontally_scrollable;\n    },\n});\n\n// Make Visible in scroll\n$.fn.makeVisibleInScroll = function (parent_id) {\n    var absoluteParent = null;\n    if (typeof parent_id === \"string\") {\n        absoluteParent = $(\"#\" + parent_id);\n    } else if (parent_id) {\n        absoluteParent = $(parent_id);\n    }\n\n    return this.each(function () {\n        var $this = $(this),\n            parent;\n        if (!absoluteParent) {\n            parent = $this.parents(\":scrollable\");\n            if (parent.length > 0) {\n                parent = $(parent[0]);\n            } else {\n                parent = $(window);\n            }\n        } else {\n            parent = absoluteParent;\n        }\n\n        var elemTop = $this.position().top;\n        var elemBottom = $this.height() + elemTop;\n\n        var viewTop = parent.scrollTop();\n        var viewBottom = parent.height() + viewTop;\n\n        if (elemTop < viewTop) {\n            parent.scrollTop(elemTop);\n        } else if (elemBottom > viewBottom - parent.height() / 2) {\n            parent.scrollTop(elemTop - (parent.height() - $this.height()) / 2);\n        }\n    });\n};\n\n//Work around warning for jQuery 3.x:\n//JQMIGRATE: jQuery.fn.offset() requires an element connected to a document\n$.fn.safeOffset = function () {\n    var docElem,\n        elem = this[0],\n        origin = { top: 0, left: 0 };\n\n    if (!elem || !elem.nodeType) {\n        return origin;\n    }\n\n    docElem = (elem.ownerDocument || document).documentElement;\n    if (!$.contains(docElem, elem)) {\n        return origin;\n    }\n\n    return $.fn.offset.apply(this, arguments);\n};\n\n//Make absolute location\n$.fn.setPositionAbsolute = function (element, offsettop, offsetleft) {\n    return this.each(function () {\n        // set absolute location for based on the element passed\n        // dynamically since every browser has different settings\n        var $this = $(this);\n        var thiswidth = $(this).width();\n        var pos = element.safeOffset();\n        var width = element.width();\n        var height = element.height();\n        var setleft = pos.left + width - thiswidth + offsetleft;\n        var settop = pos.top + height + offsettop;\n        $this.css({\n            \"z-index\": 1,\n            \"position\": \"absolute\",\n            \"marginLeft\": 0,\n            \"marginTop\": 0,\n            \"left\": setleft + \"px\",\n            \"top\": settop + \"px\",\n            \"width\": thiswidth,\n        });\n        $this.remove().appendTo(\"body\").show();\n    });\n};\n\n$.fn.positionAncestor = function (selector) {\n    var left = 0;\n    var top = 0;\n    this.each(function () {\n        // check if current element has an ancestor matching a selector\n        // and that ancestor is positioned\n        var $ancestor = $(this).closest(selector);\n        if ($ancestor.length && $ancestor.css(\"position\") !== \"static\") {\n            var $child = $(this);\n            var childMarginEdgeLeft =\n                $child.safeOffset().left - parseInt($child.css(\"marginLeft\"), 10);\n            var childMarginEdgeTop =\n                $child.safeOffset().top - parseInt($child.css(\"marginTop\"), 10);\n            var ancestorPaddingEdgeLeft =\n                $ancestor.safeOffset().left +\n                parseInt($ancestor.css(\"borderLeftWidth\"), 10);\n            var ancestorPaddingEdgeTop =\n                $ancestor.safeOffset().top +\n                parseInt($ancestor.css(\"borderTopWidth\"), 10);\n            left = childMarginEdgeLeft - ancestorPaddingEdgeLeft;\n            top = childMarginEdgeTop - ancestorPaddingEdgeTop;\n            // we have found the ancestor and computed the position\n            // stop iterating\n            return false;\n        }\n    });\n    return {\n        left: left,\n        top: top,\n    };\n};\n\n$.fn.findInclusive = function (selector) {\n    return this.find(\"*\").addBack().filter(selector);\n};\n\n$.fn.slideIn = function (speed, easing, callback) {\n    return this.animate({ width: \"show\" }, speed, easing, callback);\n};\n\n$.fn.slideOut = function (speed, easing, callback) {\n    return this.animate({ width: \"hide\" }, speed, easing, callback);\n};\n\n// case-insensitive :contains\n$.expr[\":\"].Contains = function (a, i, m) {\n    return $(a).text().toUpperCase().indexOf(m[3].toUpperCase()) >= 0;\n};\n\n$.fn.scopedFind = function (selector) {\n    /*  If the selector starts with an object id do a global search,\n     *  otherwise do a local search.\n     */\n    if (selector.indexOf(\"#\") === 0) {\n        return $(selector);\n    } else {\n        return this.find(selector);\n    }\n};\n\nexport default undefined;\n","/**\n * Patterns ajax - AJAX injection for forms and anchors\n *\n * Copyright 2012-2013 Florian Friesdorf\n * Copyright 2012-2013 Marko Durkovic\n */\nimport $ from \"jquery\";\nimport logging from \"../../core/logging\";\nimport Parser from \"../../core/parser\";\nimport registry from \"../../core/registry\";\n\nconst log = logging.getLogger(\"pat.ajax\");\n\nexport const parser = new Parser(\"ajax\");\nparser.addArgument(\"accept\", \"text/html\");\nparser.addArgument(\"url\", function ($el) {\n    return (\n        $el.is(\"a\") ? $el.attr(\"href\") : $el.is(\"form\") ? $el.attr(\"action\") : \"\"\n    ).split(\"#\")[0];\n});\nparser.addArgument(\"browser-cache\", \"no-cache\", [\"cache\", \"no-cache\"]); // Cache ajax requests\n\nconst xhrCount = {};\nxhrCount.get = function (a) {\n    return this[a] !== undefined ? this[a] : 0;\n};\nxhrCount.inc = function (a) {\n    this[a] = this.get(a) + 1;\n    return this.get(a);\n};\n\nconst _ = {\n    name: \"ajax\",\n    trigger: \".pat-ajax\",\n    parser: parser,\n    init($el) {\n        $el.off(\".pat-ajax\");\n        $el.filter(\"a\").on(\"click.pat-ajax\", _.onTriggerEvents);\n        $el.filter(\"form\")\n            .on(\"submit.pat-ajax\", _.onTriggerEvents)\n            .on(\"click.pat-ajax\", \"[type=submit]\", _.onClickSubmit);\n        $el.filter(\":not(form,a)\").each(function () {\n            log.warn(\"Unsupported element:\", this);\n        });\n        return $el;\n    },\n    destroy($el) {\n        $el.off(\".pat-ajax\");\n    },\n    onClickSubmit(event) {\n        const el = event.target;\n        const form = el.closest(\"form\");\n        const data = {};\n        if (el.name) {\n            data[el.name] = el.value;\n        }\n        $(form).data(\"pat-ajax.clicked-data\", data);\n    },\n    onTriggerEvents(event) {\n        if (event) {\n            event.preventDefault();\n        }\n        _.request($(this));\n    },\n    request($el, opts) {\n        return $el.each(function () {\n            _._request($(this), opts);\n        });\n    },\n    _request($el, opts) {\n        const cfg = _.parser.parse($el, opts);\n        const onError = function (jqxhr, status, error) {\n            // error can also stem from a javascript\n            // exception, not only errors described in the\n            // jqxhr.\n            log.error(\"load error for \" + cfg.url + \":\", error, jqxhr);\n            $el.trigger({\n                type: \"pat-ajax-error\",\n                jqxhr: jqxhr,\n            });\n        };\n        const seqNumber = xhrCount.inc(cfg.url);\n        const onSuccess = function (data, status, jqxhr) {\n            log.debug(\"success: jqxhr:\", jqxhr);\n            if (seqNumber === xhrCount.get(cfg.url)) {\n                // if this url is requested multiple time, only return the last result\n                $el.trigger({\n                    type: \"pat-ajax-success\",\n                    jqxhr: jqxhr,\n                });\n            } else {\n                // ignore\n            }\n        };\n        const temp = $el.data(\"pat-ajax.clicked-data\");\n        const clickedData = temp ? $.param(temp) : \"\";\n        const args = {\n            context: $el,\n            data: [$el.serialize(), clickedData].filter(Boolean).join(\"&\"),\n            headers: {},\n            url: cfg.url,\n            method: $el.attr(\"method\") ? $el.attr(\"method\") : \"GET\",\n            cache: cfg.browserCache === \"cache\" ? true : false,\n        };\n\n        if (cfg.accept) {\n            args.headers.Accept = cfg.accept;\n        }\n\n        if (\n            $el.is(\"form\") &&\n            $el.attr(\"method\") &&\n            $el.attr(\"method\").toUpperCase() == \"POST\"\n        ) {\n            const formdata = new FormData($el[0]);\n            for (const key in temp) {\n                formdata.append(key, temp[key]);\n            }\n            args[\"method\"] = \"POST\";\n            args[\"data\"] = formdata;\n            args[\"cache\"] = false;\n            args[\"contentType\"] = false;\n            args[\"processData\"] = false;\n            args[\"type\"] = \"POST\";\n        }\n\n        $el.removeData(\"pat-ajax.clicked-data\");\n        log.debug(\"request:\", args, $el[0]);\n\n        // Make it happen\n        const ajax_deferred = $.ajax(args);\n\n        if (ajax_deferred) ajax_deferred.done(onSuccess).fail(onError);\n    },\n};\n\nregistry.register(_);\n\nexport default _;\n","import \"../../core/jquery-ext\"; // for :scrollable for autoLoading-visible\nimport $ from \"jquery\";\nimport ajax from \"../ajax/ajax\";\nimport dom from \"../../core/dom\";\nimport logging from \"../../core/logging\";\nimport Parser from \"../../core/parser\";\nimport registry from \"../../core/registry\";\nimport utils from \"../../core/utils\";\n\nconst log = logging.getLogger(\"pat.inject\");\n//log.setLevel(logging.Level.DEBUG);\n\nconst TEXT_NODE = 3;\nconst COMMENT_NODE = 8;\n\nexport const parser = new Parser(\"inject\");\nparser.addArgument(\"default-selector\");\nparser.addArgument(\"target\");\nparser.addArgument(\"data-type\", \"html\");\nparser.addArgument(\"next-href\");\nparser.addArgument(\"source\");\nparser.addArgument(\"trigger\", \"default\", [\n    \"default\",\n    \"autoload\",\n    \"autoload-visible\",\n    \"idle\",\n]);\nparser.addArgument(\"delay\"); // only used in autoload\nparser.addArgument(\"browser-cache\", \"no-cache\", [\"cache\", \"no-cache\"]); // Cache ajax requests. Pass to pat-ajax.\nparser.addArgument(\"confirm\", \"class\", [\"never\", \"always\", \"form-data\", \"class\"]);\nparser.addArgument(\"confirm-message\", \"Are you sure you want to leave this page?\");\nparser.addArgument(\"hooks\", [], [\"raptor\"], true); // After injection, pat-inject will trigger an event for each hook: pat-inject-hook-$(hook)\nparser.addArgument(\"loading-class\", \"injecting\"); // Add a class to the target while content is still loading.\nparser.addArgument(\"executing-class\", \"executing\"); // Add a class to the element while content is still loading.\nparser.addArgument(\"executed-class\", \"executed\"); // Add a class to the element when content is loaded.\nparser.addArgument(\"class\"); // Add a class to the injected content.\nparser.addArgument(\"history\");\nparser.addArgument(\"push-marker\");\nparser.addArgument(\"scroll\");\n// XXX: this should not be here but the parser would bail on\n// unknown parameters and expand/collapsible need to pass the url\n// to us\nparser.addArgument(\"url\");\n\nconst inject = {\n    name: \"inject\",\n    trigger:\n        \".raptor-ui .ui-button.pat-inject, a.pat-inject, form.pat-inject, .pat-subform.pat-inject\",\n    parser: parser,\n\n    init($el, opts) {\n        const cfgs = this.extractConfig($el, opts);\n        if (cfgs.some((e) => e.history === \"record\") && !(\"pushState\" in history)) {\n            // if the injection shall add a history entry and HTML5 pushState\n            // is missing, then don't initialize the injection.\n            return $el;\n        }\n        $el.data(\"pat-inject\", cfgs);\n\n        if (cfgs[0].nextHref && cfgs[0].nextHref.indexOf(\"#\") === 0) {\n            // In case the next href is an anchor, and it already\n            // exists in the page, we do not activate the injection\n            // but instead just change the anchors href.\n\n            // XXX: This is used in only one project for linked\n            // fullcalendars, it's sanity is wonky and we should\n            // probably solve it differently.\n            if ($el.is(\"a\") && $(cfgs[0].nextHref).length > 0) {\n                log.debug(\n                    \"Skipping as next href is anchor, which already exists\",\n                    cfgs[0].nextHref\n                );\n                // XXX: reconsider how the injection enters exhausted state\n                return $el.attr({\n                    href: (window.location.href.split(\"#\")[0] || \"\") + cfgs[0].nextHref,\n                });\n            }\n        }\n        if (cfgs[0].pushMarker) {\n            $(\"body\").on(\"push\", (event, data) => {\n                log.debug(\"received push message: \" + data);\n                if (data == cfgs[0].pushMarker) {\n                    log.debug(\"re-injecting \" + data);\n                    this.onTrigger({ currentTarget: $el[0] });\n                }\n            });\n        }\n        if (cfgs[0].idleTrigger) {\n            this._initIdleTrigger($el, cfgs[0].idleTrigger);\n        } else {\n            switch (cfgs[0].trigger) {\n                case \"default\":\n                    cfgs.forEach((cfg) => {\n                        if (cfg.delay) {\n                            cfg.processDelay = cfg.delay;\n                        }\n                    });\n                    // setup event handlers\n                    if ($el.is(\"form\")) {\n                        $el.on(\"submit.pat-inject\", this.onTrigger.bind(this))\n                            .on(\"click.pat-inject\", \"[type=submit]\", ajax.onClickSubmit)\n                            .on(\n                                \"click.pat-inject\",\n                                \"[type=submit][formaction], [type=image][formaction]\",\n                                this.onFormActionSubmit.bind(this)\n                            );\n                    } else if ($el.is(\".pat-subform\")) {\n                        log.debug(\"Initializing subform with injection\");\n                    } else {\n                        $el.on(\"click.pat-inject\", this.onTrigger.bind(this));\n                    }\n                    break;\n                case \"autoload\":\n                    if (!cfgs[0].delay) {\n                        this.onTrigger({ currentTarget: $el[0] });\n                    } else {\n                        // generate UID\n                        const uid = Math.random().toString(36);\n                        $el.attr(\"data-pat-inject-uid\", uid);\n\n                        // function to trigger the autoload and mark as triggered\n                        const delayed_trigger = (uid_) => {\n                            // Check if the element has been removed from the dom\n                            const still_there = $(\n                                \"[data-pat-inject-uid='\" + uid_ + \"']\"\n                            );\n                            if (still_there.length == 0) return false;\n\n                            $el.data(\"pat-inject-autoloaded\", true);\n                            this.onTrigger({ currentTarget: $el[0] });\n                            return true;\n                        };\n                        window.setTimeout(\n                            delayed_trigger.bind(null, uid),\n                            cfgs[0].delay\n                        );\n                    }\n                    break;\n                case \"autoload-visible\":\n                    this._initAutoloadVisible($el, cfgs);\n                    break;\n                case \"idle\":\n                    this._initIdleTrigger($el, cfgs[0].delay);\n                    break;\n            }\n        }\n\n        log.debug(\"initialised:\", $el);\n        return $el;\n    },\n\n    destroy($el) {\n        $el.off(\".pat-inject\");\n        $el.data(\"pat-inject\", null);\n        return $el;\n    },\n\n    onTrigger(e) {\n        /* Injection has been triggered, either via form submission or a\n         * link has been clicked.\n         */\n        const $el = $(e.currentTarget);\n        const cfgs = $el.data(\"pat-inject\");\n        if ($el.is(\"form\")) {\n            $(cfgs).each((i, v) => {\n                v.params = $.param($el.serializeArray());\n            });\n        }\n        e.preventDefault && e.preventDefault();\n        $el.trigger(\"patterns-inject-triggered\");\n        this.execute(cfgs, $el);\n    },\n\n    onFormActionSubmit(e) {\n        ajax.onClickSubmit(e); // make sure the submitting button is sent with the form\n\n        const $button = $(e.target);\n        const formaction = $button.attr(\"formaction\");\n        const $form = $button.parents(\".pat-inject\").first();\n        const opts = {\n            url: formaction,\n        };\n        const $cfg_node = $button.closest(\"[data-pat-inject]\");\n        const cfgs = this.extractConfig($cfg_node, opts);\n\n        $(cfgs).each((i, v) => {\n            v.params = $.param($form.serializeArray());\n        });\n\n        e.preventDefault();\n        $form.trigger(\"patterns-inject-triggered\");\n        this.execute(cfgs, $form);\n    },\n\n    submitSubform($sub) {\n        /* This method is called from pat-subform\n         */\n        const $el = $sub.parents(\"form\");\n        const cfgs = $sub.data(\"pat-inject\");\n\n        // store the params of the subform in the config, to be used by history\n        $(cfgs).each((i, v) => {\n            v.params = $.param($sub.serializeArray());\n        });\n\n        try {\n            $el.trigger(\"patterns-inject-triggered\");\n        } catch (e) {\n            log.error(\"patterns-inject-triggered\", e);\n        }\n        this.execute(cfgs, $el);\n    },\n\n    extractConfig($el, opts) {\n        opts = $.extend({}, opts);\n\n        const cfgs = parser.parse($el, opts, true);\n        cfgs.forEach((cfg) => {\n            cfg.$context = $el;\n            // opts and cfg have priority, fall back to href/action\n            cfg.url =\n                opts.url ||\n                cfg.url ||\n                $el.attr(\"href\") ||\n                $el.attr(\"action\") ||\n                $el.parents(\"form\").attr(\"action\") ||\n                \"\";\n\n            // separate selector from url\n            const urlparts = cfg.url.split(\"#\");\n            cfg.url = urlparts[0];\n\n            if (urlparts.length > 2) {\n                log.warn(\"Ignoring additional source ids:\", urlparts.slice(2));\n            }\n\n            if (!cfg.defaultSelector) {\n                // if no selector, check for selector as part of original url\n                cfg.defaultSelector = (urlparts[1] && \"#\" + urlparts[1]) || \"body\";\n            }\n            if (cfg.delay) {\n                try {\n                    cfg.delay = utils.parseTime(cfg.delay);\n                } catch (e) {\n                    log.warn(\"Invalid delay value: \", cfg.delay);\n                    cfg.delay = null;\n                }\n            }\n            cfg.processDelay = 0;\n        });\n        return cfgs;\n    },\n\n    elementIsDirty(m) {\n        /* Check whether the passed in form element contains a value.\n         */\n        const data = $.map(m.find(\":input:not(select)\"), (i) => {\n            const val = $(i).val();\n            return Boolean(val) && val !== $(i).attr(\"placeholder\");\n        });\n        return $.inArray(true, data) !== -1;\n    },\n\n    askForConfirmation(cfgs) {\n        /* If configured to do so, show a confirmation dialog to the user.\n         * This is done before attempting to perform injection.\n         */\n        let should_confirm = false;\n        let message;\n\n        for (const cfg of cfgs) {\n            let _confirm = false;\n            if (cfg.confirm == \"always\") {\n                _confirm = true;\n            } else if (\n                cfg.confirm === \"form-data\" &&\n                cfg.target &&\n                cfg.target !== \"none\"\n            ) {\n                _confirm = this.elementIsDirty(cfg.$target);\n            } else if (cfg.confirm === \"class\" && cfg.target && cfg.target !== \"none\") {\n                _confirm = cfg.$target.hasClass(\"is-dirty\");\n            }\n            if (_confirm) {\n                should_confirm = true;\n                message = cfg.confirmMessage;\n            }\n        }\n        if (should_confirm) {\n            if (!window.confirm(message)) {\n                return false;\n            }\n        }\n        return true;\n    },\n\n    ensureTarget(cfg) {\n        /* Make sure that a target element exists and that it's assigned to\n         * cfg.$target.\n         */\n        // make sure target exist\n        if (cfg.target === \"none\") {\n            // special case, we don't want to inject anything\n            return true;\n        }\n        cfg.$target =\n            cfg.$target || (cfg.target === \"self\" ? cfg.$context : $(cfg.target));\n        if (cfg.$target.length === 0) {\n            if (!cfg.target) {\n                log.error(\"Need target selector\", cfg);\n                return false;\n            }\n            cfg.$target = this.createTarget(cfg.target);\n            cfg.$injected = cfg.$target;\n        }\n        return true;\n    },\n\n    verifySingleConfig(url, cfg) {\n        /* Verify one of potentially multiple configs (i.e. argument lists).\n         *\n         * Extract modifiers such as ::element or ::after.\n         * Ensure that a target element exists.\n         */\n        if (cfg.url !== url) {\n            // in case of multi-injection, all injections need to use\n            // the same url\n            log.error(\"Unsupported different urls for multi-inject\");\n            return false;\n        }\n        // defaults\n        cfg.source = cfg.source || cfg.defaultSelector;\n        cfg.target = cfg.target || cfg.defaultSelector;\n\n        if (!this.extractModifiers(cfg)) {\n            return false;\n        }\n        if (!this.ensureTarget(cfg)) {\n            return false;\n        }\n        this.listenForFormReset(cfg);\n        return true;\n    },\n\n    verifyConfig(cfgs) {\n        /* Verify and post-process all the configurations.\n         * Each \"config\" is an arguments list separated by the &&\n         * combination operator.\n         *\n         * In case of multi-injection, only one URL is allowed, which\n         * should be specified in the first config (i.e. arguments list).\n         *\n         * Verification for each cfg in the array needs to succeed.\n         */\n        return cfgs.every((cfg) => this.verifySingleConfig(cfgs[0].url, cfg));\n    },\n\n    listenForFormReset(cfg) {\n        /* if pat-inject is used to populate target in some form and when\n         * Cancel button is pressed (this triggers reset event on the\n         * form) you would expect to populate with initial placeholder\n         */\n        if (cfg.target === \"none\")\n            // Special case, we don't want to display any return value.\n            return;\n        const $form = cfg.$target.parents(\"form\");\n        if ($form.length !== 0 && cfg.$target.data(\"initial-value\") === undefined) {\n            cfg.$target.data(\"initial-value\", cfg.$target.html());\n            $form.on(\"reset\", () => {\n                cfg.$target.html(cfg.$target.data(\"initial-value\"));\n            });\n        }\n    },\n\n    extractModifiers(cfg) {\n        /* The user can add modifiers to the source and target arguments.\n         * Modifiers such as ::element, ::before and ::after.\n         * We identifiy and extract these modifiers here.\n         */\n        const source_re = /^(.*?)(::element)?$/;\n        const target_re = /^(.*?)(::element)?(::after|::before)?$/;\n        const source_match = source_re.exec(cfg.source);\n        const target_match = target_re.exec(cfg.target);\n\n        cfg.source = source_match[1];\n        cfg.sourceMod = source_match[2] ? \"element\" : \"content\";\n        cfg.target = target_match[1];\n        const targetMod = target_match[2] ? \"element\" : \"content\";\n        const targetPosition = (target_match[3] || \"::\").slice(2); // position relative to target\n\n        if (cfg.loadingClass) {\n            cfg.loadingClass += \" \" + cfg.loadingClass + \"-\" + targetMod;\n            if (targetPosition && cfg.loadingClass) {\n                cfg.loadingClass += \" \" + cfg.loadingClass + \"-\" + targetPosition;\n            }\n        }\n        cfg.action = targetMod + targetPosition;\n        // Once we start detecting illegal combinations, we'll\n        // return false in case of error\n        return true;\n    },\n\n    createTarget(selector) {\n        /* create a target that matches the selector\n         *\n         * XXX: so far we only support #target and create a div with\n         * that id appended to the body.\n         */\n        if (selector.slice(0, 1) !== \"#\") {\n            log.error(\"only id supported for non-existing target\");\n            return null;\n        }\n        const $target = $(\"<div />\").attr({ id: selector.slice(1) });\n        $(\"body\").append($target);\n        return $target;\n    },\n\n    stopBubblingFromRemovedElement($el, cfgs, ev) {\n        /* IE8 fix. Stop event from propagating IF $el will be removed\n         * from the DOM. With pat-inject, often $el is the target that\n         * will itself be replaced with injected content.\n         *\n         * IE8 cannot handle events bubbling up from an element removed\n         * from the DOM.\n         *\n         * See: http://stackoverflow.com/questions/7114368/why-is-jquery-remove-throwing-attr-exception-in-ie8\n         */\n        for (const cfg of cfgs) {\n            const sel = cfg.target;\n            if ($el.parents(sel).addBack(sel) && !ev.isPropagationStopped()) {\n                ev.stopPropagation();\n                return;\n            }\n        }\n    },\n\n    _performInjection(target, $el, $source, cfg, trigger, title) {\n        /* Called after the XHR has succeeded and we have a new $source\n         * element to inject.\n         */\n        if (cfg.sourceMod === \"content\") {\n            $source = $source.contents();\n        }\n        let $src;\n        // $source.clone() does not work with shived elements in IE8\n        if (document.all && document.querySelector && !document.addEventListener) {\n            $src = $source.map((idx, el) => $(el.outerHTML)[0]);\n        } else {\n            $src = $source.safeClone();\n        }\n\n        $src.findInclusive(\"img\").on(\"load\", (e) => {\n            $(e.currentTarget).trigger(\"pat-inject-content-loaded\");\n        });\n\n        const $injected = cfg.$injected || $src;\n        // Now the injection actually happens.\n        if (this._inject(trigger, $src, $(target), cfg)) {\n            this._afterInjection($el, $injected, cfg);\n        }\n        // History support. if subform is submitted, append form params\n        const glue = cfg.url.indexOf(\"?\") > -1 ? \"&\" : \"?\";\n        if (cfg.history === \"record\" && \"pushState\" in history) {\n            if (cfg.params) {\n                history.pushState(\n                    { url: cfg.url + glue + cfg.params },\n                    \"\",\n                    cfg.url + glue + cfg.params\n                );\n            } else {\n                history.pushState({ url: cfg.url }, \"\", cfg.url);\n            }\n            // Also inject title element if we have one\n            if (title)\n                this._inject(trigger, title, $(\"title\"), {\n                    action: \"element\",\n                });\n        }\n    },\n\n    _afterInjection($el, $injected, cfg) {\n        /* Set a class on the injected elements and fire the\n         * patterns-injected event.\n         */\n        $injected\n            .filter((idx, el_) => {\n                // setting data on textnode fails in IE8\n                return el_.nodeType !== TEXT_NODE;\n            })\n            .data(\"pat-injected\", { origin: cfg.url });\n\n        if ($injected.length === 1 && $injected[0].nodeType == TEXT_NODE) {\n            // Only one element injected, and it was a text node.\n            // So we trigger \"patterns-injected\" on the parent.\n            // The event handler should check whether the\n            // injected element and the triggered element are\n            // the same.\n            $injected.parent().trigger(\"patterns-injected\", [cfg, $el[0], $injected[0]]);\n        } else {\n            $injected.each((idx, el_) => {\n                // patterns-injected event will be triggered for each injected (non-text) element.\n                if (el_.nodeType !== TEXT_NODE) {\n                    $(el_)\n                        .addClass(cfg[\"class\"])\n                        .trigger(\"patterns-injected\", [cfg, $el[0], el_]);\n                }\n            });\n        }\n\n        if (cfg.scroll && cfg.scroll !== \"none\") {\n            let scroll_container = cfg.$target.parents().addBack().filter(\":scrollable\");\n            scroll_container = scroll_container.length ? scroll_container[0] : window;\n\n            // default for scroll===top\n            let top = 0;\n            let left = 0;\n\n            if (cfg.scroll !== \"top\") {\n                const scroll_target =\n                    cfg.scroll === \"target\"\n                        ? cfg.$target[0]\n                        : $injected.filter(cfg.scroll)[0];\n\n                // Get the reference element to which against we calculate\n                // the relative position of the target.\n                // In case of a scroll container of window, we do not have\n                // getBoundingClientRect method, so get the body instead.\n                const scroll_container_ref =\n                    scroll_container === window ? document.body : scroll_container;\n\n                // Calculate absolute [¹] position difference between\n                // scroll_container and scroll_target.\n                // Substract the container's border from the scrolling\n                // value, as this one isn't respected by\n                // getBoundingClientRect [²] and would lead to covered\n                // items [³].\n                // ¹) so that it doesn't make a difference, if the element\n                // is below or above the scrolling container. We just need\n                // to know the absolute difference.\n                // ²) Calculations are based from the viewport.\n                // ³) See:\n                //      https://docs.microsoft.com/en-us/previous-versions//hh781509(v=vs.85)\n                //      https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect\n                left = Math.abs(\n                    scroll_target.getBoundingClientRect().left +\n                        scroll_container_ref.scrollLeft -\n                        scroll_container_ref.getBoundingClientRect().left -\n                        dom.get_css_value(\n                            scroll_container_ref,\n                            \"border-left-width\",\n                            true\n                        )\n                );\n                top = Math.abs(\n                    scroll_target.getBoundingClientRect().top +\n                        scroll_container_ref.scrollTop -\n                        scroll_container_ref.getBoundingClientRect().top -\n                        dom.get_css_value(scroll_container_ref, \"border-top-width\", true)\n                );\n            }\n            if (scroll_container === window) {\n                scroll_container.scrollTo(left, top);\n            } else {\n                scroll_container.scrollLeft = left;\n                scroll_container.scrollTop = top;\n            }\n        }\n\n        $el[0].dispatchEvent(\n            new Event(\"pat-inject-success\", { bubbles: true, cancelable: true })\n        );\n    },\n\n    async _onInjectSuccess($el, cfgs, ev) {\n        let data = ev && ev.jqxhr && ev.jqxhr.responseText;\n        if (!data) {\n            log.warn(\"No response content, aborting\", ev);\n            return;\n        }\n        if (cfgs[0].source === \"none\") {\n            // Special case, we want to call something, but we don't want to inject anything\n            data = \"\";\n        }\n        $.each(cfgs[0].hooks || [], (idx, hook) =>\n            $el.trigger(\"pat-inject-hook-\" + hook)\n        );\n        this.stopBubblingFromRemovedElement($el, cfgs, ev);\n        const sources$ = await this.callTypeHandler(cfgs[0].dataType, \"sources\", $el, [\n            cfgs,\n            data,\n            ev,\n        ]);\n        /* pick the title source for dedicated handling later\n          Title - if present - is always appended at the end. */\n        let title;\n        if (\n            sources$ &&\n            sources$[sources$.length - 1] &&\n            sources$[sources$.length - 1][0] &&\n            sources$[sources$.length - 1][0].nodeName == \"TITLE\"\n        ) {\n            title = sources$[sources$.length - 1];\n        }\n        cfgs.forEach((cfg, idx1) => {\n            const perform_inject = () => {\n                if (cfg.target !== \"none\")\n                    cfg.$target.each((idx2, target) => {\n                        this._performInjection(\n                            target,\n                            $el,\n                            sources$[idx1],\n                            cfg,\n                            ev.target,\n                            title\n                        );\n                    });\n            };\n            if (cfg.processDelay) {\n                setTimeout(() => perform_inject(), cfg.processDelay);\n            } else {\n                perform_inject();\n            }\n        });\n        if (cfgs[0].nextHref && $el.is(\"a\")) {\n            // In case next-href is specified the anchor's href will\n            // be set to it after the injection is triggered.\n            $el.attr({ href: cfgs[0].nextHref.replace(/&amp;/g, \"&\") });\n            this.destroy($el);\n        }\n        $el.off(\"pat-ajax-success.pat-inject\");\n        $el.off(\"pat-ajax-error.pat-inject\");\n    },\n\n    async _onInjectError($el, cfgs, event) {\n        let explanation = \"\";\n        const status = event.jqxhr.status;\n        const timestamp = new Date();\n        if (status % 100 == 4) {\n            explanation =\n                \"Sorry! We couldn't find the page to load. Please make a screenshot and send it to support. Thank you!\";\n        } else if (status % 100 == 5) {\n            explanation =\n                \"I am very sorry! There was an error at the server. Please make a screenshot and contact support. Thank you!\";\n        } else if (status == 0) {\n            explanation =\n                \"It seems, the server is down. Please make a screenshot and contact support. Thank you!\";\n        }\n\n        let error_page;\n        let error_page_fragment;\n        const url_params = new URLSearchParams(window.location.search);\n        if (url_params.get(\"pat-inject-errorhandler.off\") === null) {\n            // Prepare a error page to be injected into the document.\n\n            // Try to get a suitable error message from pre-configured error pages.\n            const error_page_url = document\n                ?.querySelector(`meta[name^=pat-inject-status-${status}]`)\n                ?.getAttribute(\"content\", false);\n            error_page_fragment = error_page_url?.split(\"#\")[1];\n            error_page_fragment = error_page_fragment ? `#${error_page_fragment}` : null;\n\n            if (error_page_fragment) {\n                error_page = document.createElement(\"html\");\n                error_page.innerHTML = event.jqxhr.responseText;\n                error_page = error_page.querySelector(error_page_fragment);\n            }\n\n            if (!error_page && error_page_url) {\n                try {\n                    const error_page_response = await fetch(error_page_url, {\n                        method: \"GET\",\n                    });\n                    error_page = document.createElement(\"html\");\n                    error_page.innerHTML = await error_page_response.text();\n                    error_page = error_page.querySelector(error_page_fragment || \"body\");\n                } catch {\n                    // fall back to standard error message and ignore.\n                }\n            }\n        }\n\n        // clean up\n        cfgs.forEach((cfg) => {\n            if (\"$injected\" in cfg) {\n                cfg.$injected.remove();\n            }\n            cfg.$target.removeClass(cfg.loadingClass);\n            $el.removeClass(cfg.executingClass);\n        });\n        $el.off(\"pat-ajax-success.pat-inject\");\n        $el.off(\"pat-ajax-error.pat-inject\");\n\n        if (error_page) {\n            const error_zone = document.querySelector(error_page_fragment || \"body\");\n            error_zone.innerHTML = error_page.innerHTML;\n            registry.scan(error_zone); // initialize any patterns in error page\n        } else {\n            const msg_attr = `${explanation} Status is ${status} ${event.jqxhr.statusText}, time was ${timestamp}. You can click to close this.`;\n            $(\"body\").attr(\"data-error-message\", msg_attr);\n            $(\"body\").on(\"click\", () => {\n                $(\"body\").removeAttr(\"data-error-message\");\n                window.location.href = window.location.href; // reload\n            });\n        }\n    },\n\n    execute(cfgs, $el) {\n        /* Actually execute the injection.\n         *\n         * Either by making an ajax request or by spoofing an ajax\n         * request when the content is readily available in the current page.\n         */\n        // get a kinda deep copy, we scribble on it\n        cfgs = cfgs.map((cfg) => $.extend({}, cfg));\n        if (!this.verifyConfig(cfgs)) {\n            return;\n        }\n        if (!this.askForConfirmation(cfgs)) {\n            return;\n        }\n        if ($el.data(\"pat-inject-triggered\")) {\n            // Prevent double triggers;\n            return;\n        }\n        $el.data(\"pat-inject-triggered\", true);\n\n        for (const cfg of cfgs) {\n            // Add a execute class on the pat-inject element.\n            if (cfg?.executingClass) {\n                $el[0].classList.add(cfg.executingClass);\n            }\n            // Add a loading class to the target.\n            // Can be used for loading-spinners.\n            if (cfg?.loadingClass && cfg?.target !== \"none\") {\n                cfg.$target.addClass(cfg.loadingClass);\n            }\n        }\n\n        $el.on(\n            \"pat-ajax-success.pat-inject\",\n            this._onInjectSuccess.bind(this, $el, cfgs)\n        );\n        $el.on(\"pat-ajax-error.pat-inject\", this._onInjectError.bind(this, $el, cfgs));\n        $el.on(\"pat-ajax-success.pat-inject pat-ajax-error.pat-inject\", () =>\n            $el.removeData(\"pat-inject-triggered\")\n        );\n\n        if (cfgs[0].url.length) {\n            ajax.request($el, {\n                \"url\": cfgs[0].url,\n                \"browser-cache\": cfgs[0].browserCache,\n            });\n        } else {\n            // If there is no url specified, then content is being fetched\n            // from the same page.\n            // No need to do an ajax request for this, so we spoof the ajax\n            // event.\n            $el.trigger({\n                type: \"pat-ajax-success\",\n                jqxhr: {\n                    responseText: $(\"body\").html(),\n                },\n            });\n        }\n    },\n\n    _inject(trigger, $source, $target, cfg) {\n        // action to jquery method mapping, except for \"content\"\n        // and \"element\"\n        const method = {\n            contentbefore: \"prepend\",\n            contentafter: \"append\",\n            elementbefore: \"before\",\n            elementafter: \"after\",\n        }[cfg.action];\n\n        if (cfg.source === \"none\") {\n            $target.replaceWith(\"\");\n            return true;\n        }\n        if ($source.length === 0) {\n            log.warn(\"Aborting injection, source not found:\", $source);\n            $(trigger).trigger(\"pat-inject-missingSource\", {\n                url: cfg.url,\n                selector: cfg.source,\n            });\n            return false;\n        }\n        if (cfg.target === \"none\")\n            // Special case. Don't do anything, we don't want any result\n            return true;\n        if ($target.length === 0) {\n            log.warn(\"Aborting injection, target not found:\", $target);\n            $(trigger).trigger(\"pat-inject-missingTarget\", {\n                selector: cfg.target,\n            });\n            return false;\n        }\n        if (cfg.action === \"content\") {\n            $target.empty().append($source);\n        } else if (cfg.action === \"element\") {\n            $target.replaceWith($source);\n        } else {\n            $target[method]($source);\n        }\n        return true;\n    },\n\n    _sourcesFromHtml(html, url, sources) {\n        const $html = this._parseRawHtml(html, url);\n        return sources.map((source) => {\n            if (source === \"body\") {\n                source = \"#__original_body\";\n            }\n            if (source === \"none\") {\n                return $(\"<!-- -->\");\n            }\n            const $source = $html.find(source);\n\n            if ($source.length === 0) {\n                if (source != \"title\") {\n                    log.warn(\"No source elements for selector:\", source, $html);\n                }\n            }\n\n            $source.find('a[href^=\"#\"]').each((idx, el_) => {\n                const href = el_.getAttribute(\"href\");\n                if (href.indexOf(\"#{1}\") !== -1) {\n                    // We ignore hrefs containing #{1} because they're not\n                    // valid and only applicable in the context of\n                    // pat-clone.\n                    return;\n                }\n                // Skip in-document links pointing to an id that is inside\n                // this fragment.\n                if (href.length === 1) {\n                    // Special case for top-of-page links\n                    el_.href = url;\n                } else if (!$source.find(href).length) {\n                    el_.href = url + href;\n                }\n            });\n            return $source;\n        });\n    },\n\n    _rebaseAttrs: {\n        A: \"href\",\n        FORM: \"action\",\n        IMG: \"data-pat-inject-rebase-src\",\n        OBJECT: \"data\",\n        SOURCE: \"data-pat-inject-rebase-src\",\n        VIDEO: \"data-pat-inject-rebase-src\",\n    },\n\n    _rebaseOptions: {\n        \"calendar\": [\"url\", \"event-sources\"],\n        \"collapsible\": [\"load-content\"],\n        \"date-picker\": [\"i18n\"],\n        \"datetime-picker\": [\"i18n\"],\n        \"inject\": [\"url\"],\n    },\n\n    _rebaseHTML(base, html) {\n        if (html === \"\") {\n            // Special case, source is none\n            return \"\";\n        }\n        const $page = $(\n            html.replace(/(\\s)(src\\s*)=/gi, '$1src=\"\" data-pat-inject-rebase-$2=').trim()\n        )\n            .wrapAll(\"<div>\")\n            .parent();\n\n        $page.find(Object.keys(this._rebaseAttrs).join(\",\")).each((idx, el_) => {\n            const $el_ = $(el_);\n            const attrName = this._rebaseAttrs[el_.tagName];\n            let value = $el_.attr(attrName);\n\n            if (\n                value &&\n                value.slice(0, 2) !== \"@@\" &&\n                value[0] !== \"#\" &&\n                value.slice(0, 7) !== \"mailto:\" &&\n                value.slice(0, 4) !== \"tel:\" &&\n                value.slice(0, 4) !== \"fax:\" &&\n                value.slice(0, 7) !== \"callto:\" &&\n                value.slice(0, 10) !== \"ts3server:\" &&\n                value.slice(0, 6) !== \"teams:\" &&\n                value.slice(0, 11) !== \"javascript:\"\n            ) {\n                value = utils.rebaseURL(base, value);\n                $el_.attr(attrName, value);\n            }\n        });\n\n        for (const [pattern_name, opts] of Object.entries(this._rebaseOptions)) {\n            for (const el_ of dom.querySelectorAllAndMe(\n                $page[0],\n                `[data-pat-${pattern_name}]`\n            )) {\n                const pattern = registry.patterns?.[pattern_name];\n                const pattern_parser = pattern?.parser;\n                if (!pattern_parser) {\n                    continue;\n                }\n                // parse: no default options, possibly multiple configs, no grouping.\n                const options = pattern_parser.parse(el_, {}, true, false, false);\n                let changed = false;\n                for (const config of options) {\n                    for (const opt of opts) {\n                        const val = config[opt];\n                        if (!val) {\n                            continue;\n                        }\n                        changed = true;\n                        if (Array.isArray(val)) {\n                            config[opt] = val.map((it) => utils.rebaseURL(base, it));\n                        } else {\n                            config[opt] = utils.rebaseURL(base, val);\n                        }\n                    }\n                }\n                if (changed) {\n                    el_.setAttribute(\n                        `data-pat-${pattern_name}`,\n                        JSON.stringify(options.length === 1 ? options[0] : options)\n                    );\n                }\n            }\n        }\n\n        // XXX: IE8 changes the order of attributes in html. The following\n        // lines move data-pat-inject-rebase-src to src.\n        $page.find(\"[data-pat-inject-rebase-src]\").each((id, el_) => {\n            const $el = $(el_);\n            $el.attr(\"src\", $el.attr(\"data-pat-inject-rebase-src\")).removeAttr(\n                \"data-pat-inject-rebase-src\"\n            );\n        });\n\n        return $page\n            .html()\n            .replace(/src=\"\" data-pat-inject-rebase-/g, \"\")\n            .trim();\n    },\n\n    _parseRawHtml(html, url) {\n        url = url || \"\";\n\n        // remove script tags and head and replace body by a div\n        const title = html.match(/\\<title\\>(.*)\\<\\/title\\>/);\n        let clean_html = html\n            .replace(/<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi, \"\")\n            .replace(/<head\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/head>/gi, \"\")\n            .replace(/<body([^>]*?)>/gi, '<div id=\"__original_body\">')\n            .replace(/<\\/body([^>]*?)>/gi, \"</div>\");\n        if (title && title.length == 2) {\n            clean_html = title[0] + clean_html;\n        }\n        try {\n            clean_html = this._rebaseHTML(url, clean_html);\n        } catch (e) {\n            log.error(\"Error rebasing urls\", e);\n        }\n        const $html = $(\"<div/>\").html(clean_html);\n        if ($html.children().length === 0) {\n            log.warn(\"Parsing html resulted in empty jquery object:\", clean_html);\n        }\n        return $html;\n    },\n\n    _initAutoloadVisible($el, cfgs) {\n        if ($el.data(\"pat-inject-autoloaded\")) {\n            // ignore executed autoloads\n            return false;\n        }\n\n        const el = $el[0];\n\n        // delay: default is 200ms to allow scrolling over and past autoload-visible elements without loading them.\n        const delay = cfgs[0].delay || 200;\n        log.debug(`Delay time: ${delay}`);\n\n        // function to trigger the autoload and mark as triggered\n        const trigger = (event) => {\n            if ($el.data(\"pat-inject-autoloaded\")) {\n                log.debug(`autoload-visible trigger skipped ${el}`);\n                return false;\n            }\n            $el.data(\"pat-inject-autoloaded\", true);\n            this.onTrigger({ currentTarget: el });\n            event && event.preventDefault();\n            log.debug(`autoload-visible trigger run ${el}`);\n            return true;\n        };\n\n        // Config see: https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API\n        const intersection_observer_config = {\n            threshold: 0, // If even one pixel is visible, the callback will be run.\n            root: null, // Root is browser viewport. If the element is visible to the user, the callback will be run.\n            margin: \"0px\", // No margins. The element is not preloaded.\n        };\n\n        let timeout_id = null;\n        const observer = new IntersectionObserver((entries) => {\n            for (const entry of entries) {\n                if (entry.isIntersecting) {\n                    // Run the callback after 200ms to prevent loading all\n                    // visible elements when scrolling over.\n                    timeout_id = window.setTimeout(() => {\n                        observer.disconnect(); // Stop observing loaded elements.\n                        trigger();\n                    }, delay);\n                    log.debug(`autoload-visible intersecting ${el}`);\n                } else {\n                    window.clearTimeout(timeout_id);\n                    log.debug(`autoload-visible not intersecting ${el}`);\n                }\n            }\n        }, intersection_observer_config);\n        observer.observe(el);\n    },\n\n    _initIdleTrigger($el, delay) {\n        // XXX TODO: handle item removed from DOM\n        const timeout = parseInt(delay, 10);\n        let timer;\n\n        const onTimeout = () => {\n            this.onTrigger({ currentTarget: $el[0] });\n            unsub();\n            clearTimeout(timer);\n        };\n\n        const onInteraction = utils.debounce(() => {\n            if (!document.body.contains($el[0])) {\n                unsub();\n                return;\n            }\n            clearTimeout(timer);\n            timer = setTimeout(onTimeout, timeout);\n        }, timeout);\n\n        const unsub = () => {\n            [\"scroll\", \"resize\"].forEach((e) =>\n                window.removeEventListener(e, onInteraction)\n            );\n            [\n                \"click\",\n                \"keypress\",\n                \"keyup\",\n                \"mousemove\",\n                \"touchstart\",\n                \"touchend\",\n            ].forEach((e) => document.removeEventListener(e, onInteraction));\n        };\n\n        onInteraction();\n\n        [\"scroll\", \"resize\"].forEach((e) => window.addEventListener(e, onInteraction));\n        [\"click\", \"keypress\", \"keyup\", \"mousemove\", \"touchstart\", \"touchend\"].forEach(\n            (e) => document.addEventListener(e, onInteraction)\n        );\n    },\n\n    // XXX: simple so far to see what the team thinks of the idea\n    registerTypeHandler(type, handler) {\n        this.handlers[type] = handler;\n    },\n\n    async callTypeHandler(type, fn, context, params) {\n        type = type || \"html\";\n        if (this.handlers[type] && $.isFunction(this.handlers[type][fn])) {\n            return await this.handlers[type][fn].bind(this)(...params);\n        } else {\n            return null;\n        }\n    },\n\n    handlers: {\n        html: {\n            sources(cfgs, data) {\n                const sources = cfgs.map((cfg) => cfg.source);\n                sources.push(\"title\");\n                return this._sourcesFromHtml(data, cfgs[0].url, sources);\n            },\n        },\n    },\n};\n\n$(document).on(\"patterns-injected.inject\", (ev, cfg, trigger, injected) => {\n    /* Listen for the patterns-injected event.\n     *\n     * Remove the \"loading-class\" classes from all injection targets and\n     * then scan the injected content for new patterns.\n     */\n    if (cfg && cfg.skipPatInjectHandler) {\n        // Allow skipping this handler but still have other handlers in other\n        // patterns listen to ``patterns-injected``.\n        return;\n    }\n    if (cfg) {\n        cfg.$target.removeClass(cfg.loadingClass);\n        // Remove the executing class, add the executed class to the element with pat.inject on it.\n        $(trigger).removeClass(cfg.executingClass).addClass(cfg.executedClass);\n    }\n    if (injected.nodeType !== TEXT_NODE && injected !== COMMENT_NODE) {\n        registry.scan(injected, null, { type: \"injection\", element: trigger });\n        $(injected).trigger(\"patterns-injected-scanned\");\n    }\n});\n\n$(window).on(\"popstate\", (event) => {\n    // popstate also triggers on traditional anchors\n    if (!event.originalEvent.state && \"replaceState\" in history) {\n        try {\n            history.replaceState(\"anchor\", \"\", document.location.href);\n        } catch (e) {\n            log.debug(e);\n        }\n        return;\n    }\n    // Not only change the URL, also reload the page.\n    window.location.reload();\n});\n\n// this entry ensures that the initally loaded page can be reached with\n// the back button\nif (\"replaceState\" in history) {\n    try {\n        history.replaceState(\"pageload\", \"\", document.location.href);\n    } catch (e) {\n        log.debug(e);\n    }\n}\n\nregistry.register(inject);\nexport default inject;\n","import $ from \"jquery\";\nimport logging from \"../../core/logging\";\nimport utils from \"../../core/utils\";\nimport Base from \"../../core/base\";\nimport inject from \"../inject/inject\";\n\nvar log = logging.getLogger(\"pat.markdown\");\nvar is_markdown_resource = /\\.md$/;\n\nvar Markdown = Base.extend({\n    name: \"markdown\",\n    trigger: \".pat-markdown\",\n\n    async init() {\n        if (this.$el.is(this.trigger)) {\n            /* This pattern can either be used standalone or as an enhancement\n             * to pat-inject. The following only applies to standalone, when\n             * $el is explicitly configured with the pat-markdown trigger.\n             */\n            var source = this.$el.is(\":input\") ? this.$el.val() : this.$el.text();\n            let rendered = await this.render(source);\n            rendered.replaceAll(this.$el);\n        }\n    },\n\n    async render(text) {\n        const Showdown = (await import(\"showdown\")).default;\n\n        // Add support for syntax highlighting via pat-syntax-highlight\n        Showdown.extensions.prettify = function () {\n            return [\n                {\n                    type: \"output\",\n                    filter: function (source) {\n                        return source.replace(/(<pre>)?<code>/gi, function (match, pre) {\n                            if (pre) {\n                                return '<pre class=\"pat-syntax-highlight\" tabIndex=\"0\"><code data-inner=\"1\">';\n                            } else {\n                                return '<code class=\"pat-syntax-highlight\">';\n                            }\n                        });\n                    },\n                },\n            ];\n        };\n\n        const $rendering = $(\"<div/>\");\n        const converter = new Showdown.Converter({\n            tables: true,\n            extensions: [\"prettify\"],\n        });\n        $rendering.html(converter.makeHtml(text));\n        return $rendering;\n    },\n\n    async renderForInjection(cfg, data) {\n        var header,\n            source = data;\n        if (cfg.source && (header = /^#+\\s*(.*)/.exec(cfg.source)) !== null) {\n            source = this.extractSection(source, header[1]);\n            if (source === null) {\n                log.warn('Could not find section \"' + cfg.source + '\" in ' + cfg.url);\n                return $(\"<div/>\").attr(\"data-src\", cfg.url);\n            }\n            source += \"\\n\"; // Needed for some markdown syntax\n        }\n        const rendered = await this.render(source);\n        return rendered.attr(\"data-src\", cfg.source ? cfg.url + cfg.source : cfg.url);\n    },\n\n    extractSection(text, header) {\n        var pattern, level;\n        header = utils.escapeRegExp(header);\n        var matcher = new RegExp(\n                \"^((#+)\\\\s*@TEXT@\\\\s*|@TEXT@\\\\s*\\\\n([=-])+\\\\s*)$\".replace(\n                    /@TEXT@/g,\n                    header\n                ),\n                \"m\"\n            ),\n            match = matcher.exec(text);\n        if (match === null) {\n            return null;\n        } else if (match[2]) {\n            // We have a ##-style header.\n            level = match[2].length;\n            pattern =\n                \"^#{@LEVEL@}\\\\s*@TEXT@\\\\s*$\\\\n+((?:.|\\\\n)*?(?=^#{1,@LEVEL@}\\\\s)|.*(?:.|\\\\n)*)\";\n            pattern = pattern.replace(/@LEVEL@/g, level);\n        } else if (match[3]) {\n            // We have an underscore-style header.\n            if (match[3] === \"=\")\n                pattern =\n                    \"^@TEXT@\\\\s*\\\\n=+\\\\s*\\\\n+((?:.|\\\\n)*?(?=^.*?\\\\n=+\\\\s*$)|(?:.|\\\\n)*)\";\n            else\n                pattern =\n                    \"^@TEXT@\\\\s*\\\\n-+\\\\s*\\\\n+((?:.|\\\\n)*?(?=^.*?\\\\n[-=]+\\\\s*$)|(?:.|\\\\n)*)\";\n        } else {\n            log.error(\"Unexpected section match result\", match);\n            return null;\n        }\n        pattern = pattern.replace(/@TEXT@/g, header);\n        matcher = new RegExp(pattern, \"m\");\n        match = matcher.exec(text);\n        if (match === null) {\n            log.error(\"Failed to find section with known present header?\");\n        }\n        return match !== null ? match[0] : null;\n    },\n});\n\n$(document).ready(function () {\n    $(document.body).on(\n        \"patterns-inject-triggered.pat-markdown\",\n        \"a.pat-inject\",\n        function identifyMarkdownURLs() {\n            /* Identify injected URLs which point to markdown files and set their\n             * datatype so that we can register a type handler for them.\n             */\n            var cfgs = $(this).data(\"pat-inject\");\n            cfgs.forEach(function (cfg) {\n                if (is_markdown_resource.test(cfg.url)) {\n                    cfg.dataType = \"markdown\";\n                }\n            });\n        }\n    );\n});\n\ninject.registerTypeHandler(\"markdown\", {\n    async sources(cfgs, data) {\n        return await Promise.all(\n            cfgs.map(async function (cfg) {\n                var pat = Markdown.init(cfg.$target);\n                const rendered = await pat.renderForInjection(cfg, data);\n                return rendered;\n            })\n        );\n    },\n});\n\nexport default Markdown;\n"],"names":["methods","init","options","settings","time","initialTime","exceptionAreas","this","each","$this","$","data","lastEvent","Date","trueTime","untouched","inExceptionArea","on","mouseMoved","find","live","parent","enteredException","leftException","timeout","addClass","event","trigger","destroy","window","off","remove","removeData","hasClass","removeClass","startTimer","setTimeout","fn","Math","floor","now","diff","method","apply","Array","prototype","slice","call","arguments","scrollable","element","css","clientHeight","scrollHeight","clientWidth","scrollWidth","parent_id","absoluteParent","parents","length","elemTop","position","top","elemBottom","height","viewTop","scrollTop","viewBottom","docElem","elem","origin","left","nodeType","ownerDocument","document","documentElement","offsettop","offsetleft","thiswidth","width","pos","safeOffset","setleft","settop","appendTo","show","selector","$ancestor","closest","$child","childMarginEdgeLeft","parseInt","childMarginEdgeTop","ancestorPaddingEdgeLeft","ancestorPaddingEdgeTop","addBack","filter","speed","easing","callback","animate","a","i","m","text","toUpperCase","indexOf","log","logging","parser","Parser","addArgument","$el","is","attr","split","xhrCount","undefined","get","_","name","onTriggerEvents","onClickSubmit","warn","el","target","form","value","preventDefault","request","opts","_request","cfg","parse","seqNumber","inc","url","temp","clickedData","args","context","serialize","Boolean","join","headers","cache","browserCache","accept","Accept","formdata","FormData","key","append","debug","ajax_deferred","done","status","jqxhr","type","fail","error","registry","inject","cfgs","extractConfig","some","e","history","nextHref","href","location","pushMarker","onTrigger","currentTarget","idleTrigger","_initIdleTrigger","forEach","delay","processDelay","bind","ajax","onFormActionSubmit","uid","random","toString","uid_","_initAutoloadVisible","v","params","serializeArray","execute","$button","formaction","$form","first","$cfg_node","submitSubform","$sub","$context","urlparts","defaultSelector","utils","elementIsDirty","val","askForConfirmation","message","should_confirm","_confirm","confirm","$target","confirmMessage","ensureTarget","createTarget","$injected","verifySingleConfig","source","extractModifiers","listenForFormReset","verifyConfig","every","html","source_match","exec","target_match","sourceMod","targetMod","targetPosition","loadingClass","action","id","stopBubblingFromRemovedElement","ev","sel","isPropagationStopped","stopPropagation","_performInjection","$source","title","$src","contents","all","querySelector","addEventListener","map","idx","outerHTML","safeClone","findInclusive","_inject","_afterInjection","glue","pushState","el_","scroll","scroll_container","scroll_target","scroll_container_ref","body","abs","getBoundingClientRect","scrollLeft","dom","scrollTo","dispatchEvent","Event","bubbles","cancelable","_onInjectSuccess","responseText","hooks","hook","callTypeHandler","dataType","sources$","nodeName","idx1","perform_inject","idx2","replace","_onInjectError","explanation","timestamp","URLSearchParams","search","error_page_url","getAttribute","error_page_fragment","error_page","createElement","innerHTML","fetch","error_page_response","executingClass","error_zone","msg_attr","statusText","removeAttr","classList","add","contentbefore","contentafter","elementbefore","elementafter","replaceWith","empty","_sourcesFromHtml","sources","$html","_parseRawHtml","_rebaseAttrs","A","FORM","IMG","OBJECT","SOURCE","VIDEO","_rebaseOptions","_rebaseHTML","base","$page","trim","wrapAll","Object","keys","$el_","attrName","tagName","entries","pattern_name","pattern","pattern_parser","changed","config","opt","isArray","it","setAttribute","JSON","stringify","match","clean_html","children","timeout_id","observer","IntersectionObserver","isIntersecting","disconnect","clearTimeout","threshold","root","margin","observe","timer","onTimeout","unsub","onInteraction","contains","removeEventListener","registerTypeHandler","handler","handlers","push","injected","skipPatInjectHandler","executedClass","originalEvent","state","reload","replaceState","is_markdown_resource","Markdown","Base","render","replaceAll","Showdown","default","extensions","prettify","pre","$rendering","converter","Converter","tables","makeHtml","renderForInjection","header","extractSection","rendered","level","matcher","RegExp","ready","test","Promise","pat"],"sourceRoot":""}